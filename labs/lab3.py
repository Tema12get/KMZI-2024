def feistel_encrypt(block, round_key, number_round):
    """
    Реализация сети Фейстеля для шифрования.
    :param block: Входной блок (8 байт).
    :param round_key: Список итерационных ключей.
    :number_round: Номер раунда.
    :return: Зашифрованный блок (8 байт).
    """

    L, R = block[:4], block[4:]                     # Разделение блока на L и R
    T = [x ^ k for x, k in zip(R, round_key)]       # XOR с итерационным ключом
    F_result = F(T, number_round)                   # F-преобразование
    L, R = R, [x ^ k for x, k in zip(L, F_result)]  # Обновление L и R

    return L + R                                    # Конкатенация R и L для выхода


def feistel_decrypt(block, round_key, number_round):
    """
    Реализация сети Фейстеля для расшифрования.
    :param block: Зашифрованный блок (8 байт).
    :param round_key: Список итерационных ключей.
    :number_round: Номер раунда.
    :return: Расшифрованный блок (8 байт).
    """

    L, R = block[:4], block[4:]                     # Разделение блока на L и R
    T = [x ^ k for x, k in zip(L, round_key)]       # XOR с итерационным ключом
    F_result = F(T, number_round)                   # F-преобразование
    R, L = L, [x ^ k for x, k in zip(R, F_result)]  # Обновление L и R

    return L + R                                    # Конкатенация R и L для выхода


def F(input_block, score):
    """
    Выполняет подстановку по таблице substitution_boxes для каждого байта input_block
    на основании номера итерации score.

    :param input_block: Список байт
    :param score: Номер итерации
    :return: Список измененных байт
    """
    substitution_boxes = [
        [0xF, 0xE, 0xD, 0xC, 0x9, 0x7, 0x2, 0x0, 0x1, 0x6, 0x4, 0x3, 0xA, 0x5, 0x8, 0xB],
        [0xF, 0xE, 0x9, 0xA, 0x3, 0x6, 0x4, 0x0, 0x5, 0x1, 0x8, 0x2, 0x7, 0xC, 0xD, 0xB],
        [0xF, 0xB, 0x2, 0x5, 0x6, 0x9, 0x0, 0xA, 0x7, 0x8, 0x1, 0x3, 0xD, 0xC, 0x4, 0xE],
        [0xF, 0xC, 0x5, 0xA, 0x0, 0x6, 0x9, 0x8, 0x2, 0x1, 0x7, 0x3, 0x4, 0xB, 0xD, 0xE],
        [0x0, 0xB, 0xD, 0x3, 0x9, 0x8, 0x1, 0x7, 0xF, 0x6, 0xC, 0x4, 0x5, 0xA, 0x2, 0xE],
        [0x0, 0xD, 0x2, 0xA, 0xB, 0x6, 0x5, 0x3, 0x7, 0x4, 0xC, 0x8, 0x9, 0x1, 0xF, 0xE],
        [0xF, 0x7, 0xA, 0x4, 0xB, 0x1, 0x6, 0x8, 0x2, 0x3, 0x5, 0x9, 0x0, 0xC, 0xD, 0xE],
        [0xF, 0xC, 0x1, 0x3, 0xB, 0xA, 0x4, 0x5, 0x6, 0x7, 0x0, 0x9, 0xD, 0x2, 0x8, 0xE],
        [0xF, 0xA, 0xB, 0x8, 0x1, 0x3, 0x6, 0x5, 0x9, 0x4, 0x7, 0xE, 0x2, 0xC, 0xD, 0x0],
        [0xF, 0xA, 0x1, 0x0, 0x6, 0x8, 0x7, 0x3, 0x5, 0xC, 0x4, 0x2, 0xB, 0x9, 0xD, 0xE],
        [0x0, 0xD, 0x4, 0xC, 0xA, 0x8, 0x7, 0xF, 0x6, 0x1, 0x5, 0x2, 0x9, 0xB, 0x3, 0xE],
    ]

    sbox = substitution_boxes[score]
    result = []

    for value in input_block:
        # Извлекаем старший и младший полубайты
        high_nibble = (value >> 4) & 0xF  # Старший полубайт
        low_nibble = value & 0xF          # Младший полубайт

        # Заменяем полубайты через таблицу подстановки
        new_high = sbox[high_nibble]
        new_low = sbox[low_nibble]

        # Собираем новое значение
        new_value = (new_high << 4) | new_low
        result.append(new_value)

    return result


def splitting(full_key, size):
    return [full_key[i:i + size] for i in range(0, len(full_key), size)]


size_block = 64
all_round = 11
key = [0x57, 0xf7, 0x64, 0xa4,
       0xbf, 0x1f, 0x47, 0x88,
       0xb1, 0x84, 0x52, 0xfc,
       0x81, 0x96, 0xdc, 0x79,
       0x34, 0xbd, 0x13, 0xbe,
       0xc7, 0x68, 0xf3, 0x25,
       0x49, 0xe7, 0x05, 0x76,
       0x9b, 0x2f, 0x5d, 0x0b,
       0x69, 0xa4, 0x00, 0xcd,
       0x6b, 0xdd, 0x20, 0xd7,
       0xe2, 0x16, 0xf1, 0xc1]
text = [0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
        0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,
        0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,
        0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,
        0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37]

key = splitting(key, 4)
text = splitting(text, 8)
encrypt_text = []
decrypt_text = []

for step in text:
    for i in range(all_round):
        step = feistel_encrypt(step, key[i], i)
        print(f"Раунд {i}: изменения: {[hex(x) for x in step]}")
    encrypt_text.append(step)
encrypt_text = [item for sublist in encrypt_text for item in sublist]
print([hex(x) for x in encrypt_text])

encrypt_text = splitting(encrypt_text, 8)
for step in encrypt_text:
    for i in range(all_round - 1, -1, -1):
        step = feistel_decrypt(step, key[i], i)
        print(f"Раунд {i}: изменения: {[hex(x) for x in step]}")
    decrypt_text.append(step)
decrypt_text = [item for sublist in decrypt_text for item in sublist]
print([hex(x) for x in decrypt_text])

text = [item for sublist in text for item in sublist]
print(text == decrypt_text)
